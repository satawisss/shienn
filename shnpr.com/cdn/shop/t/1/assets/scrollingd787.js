import{debounce,throttle,prefersReducedMotion}from"@theme/utilities";const SCROLL_END_TIMEOUT=50;export class Scroller{element;#promise=void 0;#resolve=void 0;#throttledCallback;#endCallback;#onScrollInit;#onScrollEnd;#userEvent=!0;#ignore=!1;#isScrolling=!1;constructor(element,options){this.#throttledCallback=throttle(options.onScroll,SCROLL_END_TIMEOUT),this.#endCallback=options.onScroll,this.#onScrollInit=options.onScrollStart,this.#onScrollEnd=options.onScrollEnd,this.element=element,this.element.addEventListener("scroll",this.#handleScroll)}async to(input,options){let value;if(input instanceof HTMLElement){const paddingStart=calculatePaddingStart(this.element,this.axis);value=input[`offset${this.#edge}`]-paddingStart}else value=input;this.element[`scroll${this.#edge}`]!==value?this.#scroll({...options,method:"scrollTo",value}):this.#isScrolling&&this.#handleScrollEnd(!1)}by(value,options){this.#scroll({...options,method:"scrollBy",value})}#scroll(options){const{method,value,instant=prefersReducedMotion()}=options;this.#reset(),this.#ignore=instant,this.#userEvent=!1;const currentPosition=this.element[`scroll${this.#edge}`],targetPosition=method==="scrollBy"?currentPosition+value:value;if(Math.abs(targetPosition-currentPosition)<1)return Promise.resolve();instant||this.#setup(),this.element[method]({[this.#edge.toLowerCase()]:value,behavior:instant?"instant":"smooth"})}get axis(){return getScrollAxis(this.element)}get finished(){return this.#promise??Promise.resolve()}get#edge(){return this.axis==="x"?"Left":"Top"}#setup(){this.#promise||(this.#promise=new Promise(resolve=>this.#resolve=resolve))}#reset=()=>{this.#handleScrollEnd.cancel(),this.#resolve?.(),this.#promise=void 0,this.#resolve=void 0,this.#userEvent=!0,this.#ignore=!1};#handleScroll=()=>{if(this.#isScrolling||(this.#onScrollInit?.(),this.#isScrolling=!0),this.#ignore){this.#reset(),this.#handleScrollEnd(!1);return}const userEvent=this.#userEvent;this.#setup(),userEvent&&this.#throttledCallback(),this.#handleScrollEnd(userEvent)};#handleScrollEnd=debounce(userEvent=>{this.#resolve?.(),userEvent&&this.#endCallback(),this.#reset(),this.#isScrolling&&(this.#onScrollEnd?.(),this.#isScrolling=!1)},SCROLL_END_TIMEOUT);set snap(value){this.#ignore=!0,this.element.style.setProperty("scroll-snap-type",value?`${this.axis} mandatory`:"none")}destroy(){this.element.removeEventListener("scroll",this.#handleScroll)}}function getScrollAxis(el){return el.scrollHeight>el.clientHeight&&el.scrollWidth===el.clientWidth?"y":el.scrollWidth>el.clientWidth&&el.scrollHeight===el.clientHeight||el.scrollWidth>el.scrollHeight?"x":"y"}function calculatePaddingStart(element,axis){const computedStyle=getComputedStyle(element),value=axis==="x"?computedStyle.paddingInlineStart:computedStyle.paddingBlockStart;return parseFloat(value)}export function scrollIntoView(element,{ancestor,behavior="smooth",block="start",inline="start"}={}){if(!ancestor)return element.scrollIntoView({behavior,block,inline});const elemRect=element.getBoundingClientRect(),ancestorRect=ancestor.getBoundingClientRect(),calculateScrollOffset=(alignment,ancestorStart,ancestorLength,elemStart,elemLength,currentScroll)=>{switch(alignment){case"start":return currentScroll+elemStart-ancestorStart;case"center":return currentScroll+elemStart-ancestorStart-ancestorLength/2+elemLength/2;case"end":return currentScroll+elemStart-ancestorStart-ancestorLength+elemLength;default:return currentScroll}},scrollTop=ancestor.scrollHeight>ancestor.clientHeight?calculateScrollOffset(block,ancestorRect.top,ancestor.clientHeight,elemRect.top,elemRect.height,ancestor.scrollTop):ancestor.scrollTop,scrollLeft=ancestor.scrollWidth>ancestor.clientWidth?calculateScrollOffset(inline,ancestorRect.left,ancestor.clientWidth,elemRect.left,elemRect.width,ancestor.scrollLeft):ancestor.scrollLeft;ancestor.scrollTo({top:scrollTop,left:scrollLeft,behavior})}class ScrollHint extends HTMLElement{connectedCallback(){this.addEventListener("scroll",this.#update),this.#resizeObserver.observe(this)}disconnectedCallback(){this.removeEventListener("scroll",this.#update),this.#resizeObserver.disconnect()}#update=()=>{const{scrollTop,scrollHeight,clientHeight,scrollLeft,scrollWidth,clientWidth}=this,scrollDirection=scrollWidth>clientWidth?"horizontal":"vertical",scrollPercentage=scrollDirection==="vertical"?scrollTop/(scrollHeight-clientHeight):scrollLeft/(scrollWidth-clientWidth);this.style.maskImage=Number.isNaN(scrollPercentage)?"":`linear-gradient(
        to ${scrollDirection==="vertical"?"bottom":"right"},
        transparent ${scrollPercentage>0?1:0}%,
        black ${scrollPercentage<.1?scrollPercentage*100:10}%,
        black ${scrollPercentage>.9?scrollPercentage*100:90}%,
        transparent 100%
      )`};#resizeObserver=new ResizeObserver(this.#update)}customElements.get("scroll-hint")||customElements.define("scroll-hint",ScrollHint);
//# sourceMappingURL=/cdn/shop/t/1/assets/scrolling.js.map?v=10957690925586738441751341780
