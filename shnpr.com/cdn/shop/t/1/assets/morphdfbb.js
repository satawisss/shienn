import{Component}from"@theme/component";const MORPH_OPTIONS={childrenOnly:!0,reject(oldNode,newNode){return!!(newNode.nodeType===Node.TEXT_NODE&&newNode.nodeValue?.trim()===""||newNode instanceof HTMLTemplateElement&&newNode.shadowRootMode==="open"&&oldNode.parentElement&&newNode.parentElement&&oldNode.parentElement.tagName===newNode.parentElement.tagName&&oldNode.parentElement?.shadowRoot!=null||newNode.nodeType===Node.COMMENT_NODE&&newNode.nodeValue==="shopify:rendered_by_section_api")},onBeforeUpdate(oldNode,newNode){if(oldNode instanceof Element&&newNode instanceof Element){const attributes=["product-grid-view"];for(const attribute of attributes){const oldValue=oldNode.getAttribute(attribute),newValue=newNode.getAttribute(attribute);oldValue&&oldValue!==newValue&&newNode.setAttribute(attribute,oldValue)}const elements=["floating-panel-component"];for(const element of elements){const tagName=element.toUpperCase();if(oldNode.tagName===tagName&&newNode.tagName===tagName){const oldStyle=oldNode.getAttribute("style");oldStyle&&newNode.setAttribute("style",oldStyle)}}oldNode instanceof HTMLElement&&newNode instanceof HTMLElement&&oldNode.style.viewTransitionName&&(newNode.style.viewTransitionName=oldNode.style.viewTransitionName)}},onAfterUpdate(node){node instanceof Component&&queueMicrotask(()=>node.updatedCallback())}};export function morph(oldTree,newTree,options=MORPH_OPTIONS){if(!oldTree||!newTree)throw new Error("Both oldTree and newTree must be provided");if(typeof newTree=="string"){const parsedNewTree=new DOMParser().parseFromString(newTree,"text/html").body.firstChild;if(!parsedNewTree)throw new Error("newTree string is not valid HTML");newTree=parsedNewTree}if(options.childrenOnly)return updateChildren(newTree,oldTree,options),oldTree;if(newTree.nodeType===11)throw new Error("newTree should have one root node (not a DocumentFragment)");return walk(newTree,oldTree,options)}function walk(newNode,oldNode,options){if(!oldNode)return newNode;if(!newNode||newNode.isSameNode?.(oldNode))return oldNode;if(newNode.nodeType!==oldNode.nodeType)return newNode;if(newNode instanceof Element&&oldNode instanceof Element){if(oldNode.tagName==="SHOPIFY-ACCELERATED-CHECKOUT-CART")return oldNode;if(newNode.tagName!==oldNode.tagName)return newNode;const newKey=getNodeKey(newNode,options),oldKey=getNodeKey(oldNode,options);if(newKey&&oldKey&&newKey!==oldKey)return newNode}return oldNode instanceof Element&&oldNode.hasAttribute("data-skip-node-update")&&newNode instanceof Element&&newNode.hasAttribute("data-skip-node-update")||updateNode(newNode,oldNode,options),updateChildren(newNode,oldNode,options),options.onAfterUpdate?.(newNode),oldNode}function updateNode(newNode,oldNode,options){if(options.onBeforeUpdate?.(oldNode,newNode),(newNode instanceof HTMLDetailsElement&&oldNode instanceof HTMLDetailsElement||newNode instanceof HTMLDialogElement&&oldNode instanceof HTMLDialogElement)&&(newNode.hasAttribute("declarative-open")||(newNode.open=oldNode.open)),oldNode instanceof HTMLElement&&newNode instanceof HTMLElement)for(const attr of["slot","sizes"]){const oldValue=oldNode.getAttribute(attr),newValue=newNode.getAttribute(attr);oldValue!==newValue&&(oldValue==null?newNode.removeAttribute(attr):newNode.setAttribute(attr,oldValue))}newNode instanceof Element&&oldNode instanceof Element?oldNode.isEqualNode(newNode)||copyAttributes(newNode,oldNode):(newNode instanceof Text||newNode instanceof Comment)&&oldNode.nodeValue!==newNode.nodeValue&&(oldNode.nodeValue=newNode.nodeValue),newNode instanceof HTMLInputElement&&oldNode instanceof HTMLInputElement?updateInput(newNode,oldNode):newNode instanceof HTMLOptionElement&&oldNode instanceof HTMLOptionElement?updateAttribute(newNode,oldNode,"selected"):newNode instanceof HTMLTextAreaElement&&oldNode instanceof HTMLTextAreaElement&&updateTextarea(newNode,oldNode)}function getNodeKey(node,options){return options?.getNodeKey?.(node)??(node instanceof Element?node.id:void 0)}function updateAttribute(newNode,oldNode,name){newNode[name]!==oldNode[name]&&(oldNode[name]=newNode[name],newNode[name]!=null?oldNode.setAttribute(name,""):oldNode.removeAttribute(name))}function copyAttributes(newNode,oldNode){const oldAttrs=oldNode.attributes,newAttrs=newNode.attributes;for(const attr of Array.from(newAttrs)){const{name:attrName,namespaceURI:attrNamespaceURI,value:attrValue}=attr,localName=attr.localName||attrName;(attrName==="src"||attrName==="href"||attrName==="srcset"||attrName==="poster")&&oldNode.getAttribute(attrName)===attrValue||(attrNamespaceURI?oldNode.getAttributeNS(attrNamespaceURI,localName)!==attrValue&&oldNode.setAttributeNS(attrNamespaceURI,localName,attrValue):oldNode.hasAttribute(attrName)?oldNode.getAttribute(attrName)!==attrValue&&(attrValue==="null"||attrValue==="undefined"?oldNode.removeAttribute(attrName):oldNode.setAttribute(attrName,attrValue)):oldNode.setAttribute(attrName,attrValue))}for(const attr of Array.from(oldAttrs)){if(attr.specified===!1)continue;const{name:attrName,namespaceURI:attrNamespaceURI}=attr,localName=attr.localName||attrName;attrNamespaceURI?newNode.hasAttributeNS(attrNamespaceURI,localName)||oldNode.removeAttributeNS(attrNamespaceURI,localName):newNode.hasAttribute(attrName)||oldNode.removeAttribute(attrName)}}function updateInput(newNode,oldNode){const newValue=newNode.value;updateAttribute(newNode,oldNode,"checked"),updateAttribute(newNode,oldNode,"disabled"),newNode.indeterminate!==oldNode.indeterminate&&(oldNode.indeterminate=newNode.indeterminate),oldNode.type!=="file"&&(newValue!==oldNode.value&&(oldNode.setAttribute("value",newValue),oldNode.value=newValue),newValue==="null"&&(oldNode.value="",oldNode.removeAttribute("value")),newNode.hasAttributeNS(null,"value")?oldNode.type==="range"&&(oldNode.value=newValue):oldNode.removeAttribute("value"))}function updateTextarea(newNode,oldNode){const newValue=newNode.value;newValue!==oldNode.value&&(oldNode.value=newValue);const firstChild=oldNode.firstChild;if(firstChild?.nodeType===Node.TEXT_NODE){if(newValue===""&&firstChild.nodeValue===oldNode.placeholder)return;firstChild.nodeValue=newValue}}function updateChildren(newNode,oldNode,options){if(oldNode instanceof Element&&oldNode.hasAttribute("data-skip-subtree-update")&&newNode instanceof Element&&newNode.hasAttribute("data-skip-subtree-update"))return;let oldChild,newChild,morphed,oldMatch,offset=0;for(let i=0;oldChild=oldNode.childNodes[i],newChild=newNode.childNodes[i-offset],!(!oldChild&&!newChild);i++){if(!newChild){oldChild&&oldNode.removeChild(oldChild),i--;continue}if(!oldChild){oldNode.appendChild(newChild),offset++;continue}if(same(newChild,oldChild,options)){morphed=walk(newChild,oldChild,options),morphed!==oldChild&&(oldNode.replaceChild(morphed,oldChild),offset++);continue}if(options.reject?.(oldChild,newChild)){newNode.removeChild(newChild),i--;continue}oldMatch=null;for(let j=i;j<oldNode.childNodes.length;j++){const potentialOldNode=oldNode.childNodes[j];if(potentialOldNode&&same(potentialOldNode,newChild,options)){oldMatch=potentialOldNode;break}}oldMatch?(morphed=walk(newChild,oldMatch,options),morphed!==oldMatch&&offset++,oldNode.insertBefore(morphed,oldChild)):!getNodeKey(newChild,options)&&!getNodeKey(oldChild,options)?(morphed=walk(newChild,oldChild,options),morphed!==oldChild&&(oldNode.replaceChild(morphed,oldChild),offset++)):(oldNode.insertBefore(newChild,oldChild),offset++)}}function same(a,b,options){if(a.nodeType!==b.nodeType)return!1;if(a.nodeType===Node.ELEMENT_NODE){if(a instanceof Element&&b instanceof Element&&a.tagName!==b.tagName)return!1;const aKey=getNodeKey(a,options),bKey=getNodeKey(b,options);if(aKey&&bKey&&aKey!==bKey)return!1}return a.nodeType===Node.TEXT_NODE&&b.nodeType===Node.TEXT_NODE?a.nodeValue?.trim()===b.nodeValue?.trim():a.nodeType===Node.COMMENT_NODE&&b.nodeType===Node.COMMENT_NODE?a.nodeValue===b.nodeValue:!0}
//# sourceMappingURL=/cdn/shop/t/1/assets/morph.js.map?v=130689995393408371391751341780
